# Cerdas - System Reference & Specification

> **Purpose**: This document serves as the **Single Source of Truth** for system requirements, features, and entity relationships. Use this to validate database design consistency and feature implementation.

## 1. Core Requirements (Kebutuhan Sistem)

### 1.1 Fundamental Capabilities
1.  **Offline-First Architecture**: The Client App (Enumerator) MUST function 100% without internet connection. Data syncs when online.
2.  **No-Code Form Builder**: Admins MUST be able to define complex forms (Schemas) via a web interface without deploying code.
3.  **Multi-Tenancy**: The system MUST support multiple isolated "Projects" (e.g., "Housing 2026", "Agri Census") on a single backend instance.
4.  **Device Agnostic**: The Client App MUST run on Android (APK) and Web (PWA).

### 1.2 Performance & Scalability
1.  **High Volume**: Support 10,000+ users and millions of response rows.
2.  **Optimized Sync**: Sync payloads MUST be minimized (Delta Sync). Large media (images) sync separately.

---

## 2. Features (Fitur Utama)

### 2.1 Authentication & Identiy
-   **Method**: Laravel Sanctum (Bearer Token).
-   **Security**: Minimal session timeout for security, but long-lived tokens for mobile convenience.
-   **User Types**:
    -   **Super Admin**: System-wide control.
    -   **Project Admin**: Manages specific projects.
    -   **Supervisor**: Manages a team of enumerators.
    -   **Enumerator**: Field worker collecting data.

### 2.2 Organization Management
-   **Hierarchy**: Project -> Organization -> Members.
-   **Roles**: Roles are defined *per project* via `project_memberships`. A user can be an Admin in Project A and an Enumerator in Project B.
    -   **Values**: `['project_admin', 'org_admin', 'supervisor', 'enumerator']`.
    -   *Constraint*: A user can have only ONE role per project (`unique(['user_id', 'project_id'])`).

### 2.3 Dynamic Form Engine
-   **Schema Definition**: Forms are stored as JSON structures defined in `AppSchemaVersion` table (`schema` column).
-   **Field Types**: `text`, `number`, `select`, `image` (camera), `gps` (geolocation), `signature`, `nested` (repeater groups).
-   **Logic Engine**: Validation (`validation_js`), Visibility (`show_if_js`), and Editable (`editable_if_js`) logic are stored as **JavaScript Closures** stringified in the DB and executed safely on the Client.

### 2.4 Assignment & Import (Prelist)
-   **Prelist**: Large datasets (Excel/CSV) imported by Admin to generate `Assignments`.
-   **Distribution**: Assignments are linked to specific `AppSchemaVersion` and `Enumerator`.
-   **Status Workflow**: `assigned` -> `in_progress` -> `completed` -> `synced`.
-   **Reference**: `app_schema_version_id` links to the specific form version used for data collection.

### 2.5 Data Synchronization
-   **Direction**:
    -   **Pull**: Client fetches Schemas, Assignments (assigned to them).
    -   **Push**: Client sends Responses (new/updated).
-   **Conflict Resolution**: **Last-Write-Wins**. The latest timestamp from Client or Server overwrites the other. (Chosen for simplicity in field survey context).
-   **Soft Failures**: Individual record failures during sync (e.g., validation error) do NOT block the entire batch.

---

## 3. Entity Relationships (Relasi Antar Entitas)

```mermaid
erDiagram
    Users ||--o{ ProjectMemberships : "has"
    Projects ||--o{ ProjectMemberships : "has"
    Organizations ||--o{ ProjectMemberships : "belongs to"
    
    Projects ||--o{ Organizations : "contains"
    Projects ||--o{ AppSchemas : "owns"
    
    AppSchemas ||--o{ AppSchemaVersions : "has history"
    
    AppSchemaVersions ||--o{ Fields : "defines"
    AppSchemaVersions ||--o{ Assignments : "template for"
    
    Users ||--o{ Assignments : "is enumerator for"
    Users ||--o{ Assignments : "is supervisor for"
    Organizations ||--o{ Assignments : "territory of"
    
    Assignments ||--o{ Responses : "collects"
    
    Responses ||--o{ Responses : "parent-child (nested)"
```

### 3.1 Key Foreign Key Rules
1.  **`project_memberships`**: Connects `user_id`, `project_id`, and `organization_id`.
    -   *Constraint*: Unique `[user_id, project_id]`. One role per user per project.
2.  **`assignments`**:
    -   `app_schema_version_id`: **CRITICAL**. Links to a specific *immutable* version of the form. Not the parent `app_schema`.
    -   `enumerator_id`: The user performing the survey.
    -   `prelist_data` (JSON): Static data from import (Name, Address) that cannot be changed by enumerator.
3.  **`responses`**:
    -   `assignment_id`: Links data back to the assignment.
    -   `local_id` (UUID): Generated by client to ensure uniqueness before sync.
    -   `data` (JSON): The actual survey answers. EAV-style storage.

---

## 4. Key Workflows & Interaction Flow (Sequence Diagram)

This diagram illustrates the end-to-end flow from Project Creation by Central Authority to Data Collection by Enumerators.

```mermaid
sequenceDiagram
    autonumber
    
    box "Head Office" #f0f4f8
        participant CA as Central Authority
        participant PA as Project Admin
    end
    
    box "Field Management" #e3f2fd
        participant SPV as Supervisor
        participant ENUM as Enumerator
    end
    
    box "System" #fef3c7
        participant API as Backend API
        participant DB as Database
    end

    %% PHASE 1: SETUP
    rect rgb(240, 248, 255)
        note over CA, PA: Phase 1: Project & Org Setup
        CA->>API: POST /projects (Create Project "Housing 2026")
        API->>DB: Insert Project
        CA->>API: POST /organizations (Create Org "Dinas Perumahan")
        API->>DB: Insert Org
        CA->>API: POST /memberships (Assign User as Project Admin)
        API->>DB: Insert ProjectMembership (role: project_admin)
    end

    %% PHASE 2: DESIGN (No-Code Editor)
    rect rgb(255, 248, 240)
        note over PA, DB: Phase 2: Schema Design (Web Editor)
        PA->>API: POST /app-schemas (Create Form)
        PA->>API: PUT /app-schemas/{id} (Edit Fields & Logic)
        PA->>PA: Live Preview (Realtime JS Eval)
        PA->>API: POST /app-schemas/{id}/publish (Publish V1)
        API->>DB: Lock V1, Insert AppSchemaVersion
    end

    %% PHASE 3: DEPLOYMENT
    rect rgb(240, 255, 240)
        note over PA, ENUM: Phase 3: Assignment Distribution
        PA->>API: POST /import/prelist (Upload Excel/CSV)
        API->>DB: Create Assignments (Status: assigned)
        note right of DB: Link: 1 Assign -> 1 Org, 1 Spv, 1 Enum
        
        PA->>SPV: Notify (Start Survey)
        PA->>ENUM: Notify (Start Survey)
    end

    %% PHASE 4: EXECUTION (Offline Capable)
    rect rgb(255, 240, 245)
        note over ENUM, DB: Phase 4: Data Collection (Offline First)
        ENUM->>API: GET /auth/login (Login)
        ENUM->>API: GET /assignments (Pull Assignments)
        API->>DB: Query Assignments (filter by enumerator_id)
        API-->>ENUM: Return List + Linked Schema V1
        
        note right of ENUM: GO OFFLINE
        ENUM->>ENUM: Fill Form (Support Nested: House->Families->Members)
        ENUM->>ENUM: Validate Complex Logic (JS Closures)
        ENUM->>ENUM: Save "Response" locally (UUID generated)
        note right of ENUM: GO ONLINE
        
        ENUM->>API: POST /responses/sync (Push Data)
        API->>DB: Upsert Response (Last-Write-Wins)
        API-->>ENUM: Ack Success
    end

    %% PHASE 5: MONITORING
    rect rgb(245, 245, 245)
        note over SPV, API: Phase 5: Monitoring
        SPV->>API: GET /reports/progress
        API->>DB: Aggregate Status (Completed vs Total)
        API-->>SPV: Return Dashboard Data
    end
```

### 4.2 Scalability & Performance Limits

**Current Capacity Estimates**:
-   **Users**: 70,000+ (Supported). Standard MySQL indexing on `users` and `project_memberships` handles this efficiently.
-   **Responses**: 500,000+ (Supported). `responses` table uses JSON for flexibility.
    -   *Read Performance*: Direct filtering on JSON keys will be slow. **Strategy**: Use Generated Columns (MySQL 5.7+) for high-frequency report filters.
    -   *Write Performance (Sync)*: Current `ResponseController` processes records sequentially (O(N)). For extreme loads (>1000 syncs/sec), refactor to `Batch Upsert` or Queue-based processing.

---

## 5. Invariants & Business Rules (Aturan Bisnis)

1.  **Immutable Schema Versions**: Once an `AppSchemaVersion` is published, it **CANNOT** be modified. Any change requires a new Version. This ensures data consistency for existing responses.
2.  **Data Isolation**: Users must **NEVER** see data from Projects they are not members of. API must always filter by `project_memberships`.
3.  **Role Scoping**:
    -   **Enumerators**: Read `Assignments` (assigned to them), Write `Responses`.
    -   **Supervisors**: Read `Assignments` (assigned to their team), Read `Responses`.
4.  **Sync Idempotency**: Sending the same Response payload twice must verify `local_id` and update (if newer) or ignore, never duplicate.

---

## 6. Client App UI Flows (Alur Antarmuka)

Detailed user journey for the Mobile/PWA Client App.

```mermaid
sequenceDiagram
    autonumber
    
    actor User as Enumerator
    participant UI as Client UI (Vue)
    participant Store as Local Store (Pinia/SQLite)
    participant API as Backend API

    %% 1. APP LAUNCH
    rect rgb(240, 248, 255)
        note over User, UI: Flow 1: App Launch & Login
        User->>UI: Open App
        UI->>Store: Check Auth Token
        alt Token Valid
            Store-->>UI: Return User Profile
            UI->>UI: Navigate to Home
        else Token Missing/Expired
            UI->>UI: Navigate to Login
            User->>UI: Enter Email/Pass
            UI->>API: POST /auth/login
            API-->>UI: Return Token + User
            UI->>Store: Save Token
            UI->>UI: Navigate to Home
        end
    end

    %% 2. HOME & SYNC
    rect rgb(255, 248, 240)
        note over User, UI: Flow 2: Dashboard & Sync
        UI->>Store: Load Assignments (Local)
        Store-->>UI: List [Assigned, InProgress, Completed]
        
        alt User clicks "Sync Now" (Online)
            UI->>API: GET /assignments (Pull)
            API-->>UI: New Assignments + Schemas
            UI->>Store: Save Assignments
            
            UI->>Store: Get unsynced Responses
            UI->>API: POST /responses/sync (Push)
            API-->>UI: Success Ack
            UI->>Store: Mark Synced
            UI->>UI: Update Status Indicators
        end
    end

    %% 3. DATA ENTRY
    rect rgb(240, 255, 240)
        note over User, UI: Flow 3: Form Filling (Offline)
        User->>UI: Click Assignment #123
        UI->>Store: Get Schema & Prelist Data
        UI->>UI: Render Form (Dynamic Components)
        
        loop Entry
            User->>UI: Input Field Value
            UI->>Store: Auto-save Draft (Debounced)
            UI->>UI: Validate Field (JS Closure)
            opt Error
                UI-->>User: Show Validation Message
            end
        end
        
        User->>UI: Click "Submit/Finish"
        UI->>UI: Run Full Validation
        alt Valid
            UI->>Store: Save Status = 'completed'
            UI->>UI: Navigate Home
            note right of UI: Ready to Sync
        end
    end
```

---

## 7. Client Dynamic View Engine (AppSheet Parity)

The client application (`apps/client`) has transitioned from a hardcoded page structure to a **Dynamic View Engine** driven by server-side configuration.

### 7.1 Architecture
*   **Configuration**: Stored in `app_schema_versions.layout` (JSON).
*   **Sync**: Pulled during login/sync and stored locally in SQLite `app_schemas` table.
*   **Routing**:
    *   `/app/:schemaId`: Loads the App Shell with Tab Navigation based on `layout.navigation.primary`.
    *   `/app/:schemaId/view/:viewName/:recordId`: Renders a specific view (Detail, Form) for a specific record.

### 7.2 Core Components
1.  **`AppShell.vue`**: The main container. Reads `layout`, renders the Tab Bar, and instantiates `ViewRenderer` for the active tab.
2.  **`ViewRenderer.vue`**: The central factory component. props: `{ config, data }`. Switch-cases on `config.type` to render:
    *   `DeckView` (`type: deck`): List view with Image/Title/Subtitle.
    *   `MapView` (`type: map`): Geospatial view (Leaflet/Google).
    *   `DetailView` (`type: detail`): Read-only record detail.
    *   `FormView`: Typically handles `edit` actions (integrated via `AssignmentDetail`).
    *   **Performance Note**: `FormRenderer` implements **Progressive Rendering** (Lazy Loading), rendering fields in chunks of 20 to support large schemas (70+ questions) without UI lag.

### 7.3 Data Flow
1.  **Layout**: `DB.app_schemas.layout` -> `AppShell` -> `ViewRenderer` -> `SpecificView`.
2.  **Data**: `DB.assignments` / `DB.responses` -> `AppShell` (filtered) -> `ViewRenderer` -> `SpecificView`.
3.  **Actions**: User Click -> `SpecificView` emits `action` -> `ViewRenderer` handles navigation (e.g., to Detail or Form).

### 7.4 Example Layout JSON
```json
{
  "app_name": "Survey App",
  "navigation": { "primary": ["map_view", "list_view"] },
  "views": {
    "map_view": { "type": "map", "source": "assignments", "options": { "gps_column": "loc" } },
    "list_view": { "type": "deck", "source": "assignments", "options": { "action": "view_detail" } },
    "view_detail": { "type": "detail", "source": "assignments", "options": { "actions": ["edit"] } }
  }
}
```

---

## 8. Key Decisions & Rationales (Tanya Jawab Awal)

**Q: Why separate `AppSchemaVersion` from `AppSchema`?**
A: Surveys change over time. Old responses must remain valid against the *exact* schema version used during collection. Changing a question in V2 should not break V1 responses.

**Q: Why JavaScript closures for validation?**
A: We need complex validation (e.g., "Age > 18 if Married") to run **Offline**. Backend Languages (PHP) can't run on the client. JS can run on both.

**Q: Why Shared Database for Multi-tenancy?**
A: Simplicity and cost. A single database with `project_id` columns is easier to maintain and cheaper to host than spinning up a new DB for every project.

**Q: Why Last-Write-Wins for Sync?**
A: Real-time collaborative editing is NOT the goal. Field surveys are generally single-user (one enumerator per assignment). LWW is robust enough for occasional conflict resolution without complex merging UIs.
